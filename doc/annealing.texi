\input texinfo.tex
@c %**start of header
@setfilename annealing.info
@settitle Annealing
@c %**end of header

@include version.texiinc

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c ------------------------------------------------------------

@macro authorname{}
Mark Galassi and Marco Maggi
@end macro

@macro copyrightyears{}
1996, 1997, 1998, 1999, 2000, 2007
@end macro

@macro gnu{}
@acronym{GNU}
@end macro

@macro gpl{}
@acronym{GPL}
@end macro

@macro gsl{}
@acronym{GSL}
@end macro

@macro api{}
@acronym{API}
@end macro

@c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@macro function{NAME}
@code{\NAME\()}
@end macro

@macro null{}
@code{NULL}
@end macro

@macro pkgconfig{}
@command{pkg-config}
@end macro

@c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@macro gslref{NODE}
@xref{\NODE\,\NODE\,gsl-ref,gsl-ref}
@end macro

@macro autoconfref{NODE}
@xref{\NODE\,\NODE\,autoconf,autoconf}
@end macro

@c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@titlepage
@title Annealing
@subtitle @version{}
@author @authorname{}
@page
@vskip 0pt plus 1filll
@noindent
Copyright @copyright{}  @copyrightyears{}  by @authorname{}

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front--Cover Texts, and no Back--Cover Texts.  A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
@end titlepage


@c ------------------------------------------------------------

@ifinfo
@dircategory Mathematics
@direntry
* annealing: (annealing).       A reworking of GSL's simulated annealing module.
@end direntry
@end ifinfo


@c ------------------------------------------------------------
@ifnottex
@node Top
@top Annealing


@noindent
Annealing is a C language library extension the for @gsl{}, the @gnu{}
Scientific Library, attempting a redesign of the simulated annealing
module. This document describes version @version{}.

The package is distributed under the terms of the @gnu{} General Public
License (@gpl{}).

Annealing is distributed at the @acronym{GNA!} site:

@center @url{http://gna.org/projects/annealing}

Copyright @copyright{}  @copyrightyears{}  by @authorname{}.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front--Cover Texts, and no Back--Cover Texts.  A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.

@menu
* overview::                    Overview of the package. 
* annealing::                   Simulated annealing.

Appendices

* References::                  Bibliography and references.
* Documentation License::       GNU Free Documentation License.
* Package License::             GNU General Public License.
* library version::             How to interpret the library version.

Indexes

* Concept Index::               An entry for each concept. 
* Function Index::              An entry for each function. 
* Variable Index::              An entry for each variable. 
* Type Index::                  An entry for each type. 

@detailmenu
 --- The Detailed Node Listing ---

Simulated annealing

* annealing algorithm::         The basic algorithm.
* annealing types::             Data types.
* annealing basic::             Interface to the basic algorithm.
* annealing multi::             Interface to the multi-best algorithm.
* annealing many::              Interface to the many-tries algorithm.

@end detailmenu
@end menu

@end ifnottex


@c ------------------------------------------------------------
@node overview
@chapter Overview of the package


@menu
* overview using::              Using the library.
* overview autoconf::           Using @gnu{} Autoconf.
* overview pkgconfig::          Using pkgconfig.
@end menu


@noindent
Annealing is a C language extension library for @gsl{}, the @gnu{}
Scientific Library, attempting a redesign of the simulated annealing
module.

The library is developed and tested under the Linux+@gnu{} system and
officially it supports only the @gnu{} infrastructure: requires the
@gnu{} C library and compiles fine with the @gnu{} C compiler
(@code{-std=c99 -pedantic} switches). The building infrastructure
requires @gnu{} Make, @gnu{} Bash and the other common tools
(@command{rm}, @command{mkdir}, @dots{}).

Notice that Annealing's @api{} violates the @gsl{}'s Design Document;
specifically the requirement of section 3.18: ``Algorithm
decomposition''. Annealing uses callbacks everywhere, while the Document
requires for the algorithm to be split into an initialise, iterate, test
form.


@c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node overview using
@section Using the library


@noindent
In the following we assume that the library is installed under the
@file{/usr/local} hierarchy.

A shell script is installed on the system to provide informations about
version numbers and installation directories; it should be
@file{/usr/local/bin/annealing-config}. Run @command{annealing-config} without
arguments for the usage screen. An example of output for the important
options is:

@example
$ annealing-config --package-xversion
0.2a1

$ annealing-config --package-version
0.2.0

$ annealing-config --library-interface-version
1.0

$ annealing-config --pkgincludedir
/usr/local/include/annealing/0.2a1

$ annealing-config --libdir
/usr/local/lib

$ annealing-config --library-id
annealing2.0
@end example

There is a single header file that must be included in C sources:
@file{annealing.h}; in our source code we can put:

@example
#include <annealing.h>
@end example

@noindent
and use the output of @code{annealing-config --pkgincludedir} as argument to
the @code{-I} option of the C preprocessor.

The libraries (shared and static) are installed under the directory
obtained by running @code{annealing-config --libdir}; we can use its
output as argument of the @code{-L} option to the linker.

If we want to link with the shared or static library we take the output
of @code{annealing-config --library-id} and use it as value for the @code{-l}
option to the linker.


@c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node overview autoconf
@section Using @gnu{} Autoconf


@noindent
If you use @gnu{} Autoconf to configure your application you can embed
in your distribution the file @file{annealing.m4}, installed under
@file{$prefix/share/aclocal}, and load it in your @file{configure.ac} by
putting:

@example
m4_include(annealing.m4)
@end example

@noindent
in @file{aclocal.m4}. Notice that @gsl{} distributes its own Autoconf
plug--in, a file named @file{gsl.m4}. The @file{annealing.m4} macro file
defines a function that can be invoked with:

@example
ANNEALING_LIBRARY(1,0)
@end example

@noindent
it finds and invokes @command{annealing-config} to acquire installation
directories and library names. The macro accepts two arguments: the
major and minor interface version numbers that are needed (@ref{library
version}); both of the arguments are optional, but it is recommended to
specify them.

@code{ANNEALING_LIBRARY} defines the following symbols:

@table @code
@item @@ANNEALING_INCLUDEDIR@@
the directory under which header files are installed, example:
@file{/usr/local/include/annealing/0.2a1};

@item @@ANNEALING_LIBDIR@@
the directory under which shared and static libraries are installed,
example: @file{/usr/local/lib};

@item @@ANNEALING_LDFLAGS@@
the linker option @code{-L} with the value of
@code{@@ANNEALING_LIBDIR@@} appended, example: @file{-L/usr/local/lib};
this value should be appended to the value of the @code{LDFLAGS}
variable in your @file{Makefile};

@item @@ANNEALING_LIBRARY_ID@@
the identifier of the shared or static library, example:
@code{annealing1.0};

@item @@ANNEALING_LIBS@@
the linker option @code{-l} with the value of
@code{@@ANNEALING_LIBRARY_ID@@} appended, example:
@code{-lannealing1.0}; this value must be appended to the command line
of the linking command for libraries and programs that directly use
Annealing; for example: it could be appended to the value of the
@code{LIBS} variable in your @file{Makefile}.
@end table

@autoconfref{Preset Output Variables}, for details on the
@file{Makefile} variables @code{LDFLAGS} and @code{LIBS}.


@c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node overview pkgconfig
@section Using pkgconfig


@noindent
@pkgconfig{} is a program (a compiled executable) that inspects a
database of package meta informations and prints to its standard output
channel informations about installed packages and libraries.  Annealing
installs a meta data file for use with @pkgconfig{}, it should be:

@example
$@{libdir@}/pkgconfig/annealing.pc
@end example

@noindent
notice that the @gsl{} distributes its own @pkgconfig{} meta file, a
file named @file{gsl.pc}.

For the full list of available informations look in the file itself, and
remember that the value of all the variables set in the meta file can be
printed with:

@example
$ pkg-config annealing --variable=<VARNAME>
@end example

@noindent
an example of output for the important variables is:

@example
$ pkg-config annealing --variable=PACKAGE_XVERSION
0.2a1

$ pkg-config annealing --variable=PACKAGE_VERSION
0.2.0

$ pkg-config annealing --variable=library_interface_version
1.0

$ pkg-config annealing --variable=pkgincludedir
/usr/local/include/annealing/0.2a1

$ pkg-config annealing --variable=libdir
/usr/local/lib

$ pkg-config annealing --variable=library_id
annealing1.0
@end example

The @option{--libs} option outputs something like:

@example
$ pkg-config annealing --libs
-L/usr/local/lib -lannealing1.0 -lgsl -lgslcblas -lm
@end example

@noindent
while the list of preprocessor options is:

@example
$ pkg-config annealing --cflags
-I/usr/local/include/annealing/0.2a1 -I/usr/local/include
@end example

Notice that:

@example
$ pkg-config annealing --modversion
1.0
@end example

@noindent
because what matters is the version of the @api{}, not the package
distribution version.


@c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node annealing
@chapter Simulated annealing


@menu
* annealing algorithm::         The basic algorithm.
* annealing types::             Data types.
* annealing basic::             Interface to the basic algorithm.
* annealing multi::             Interface to the multi-best algorithm.
* annealing many::              Interface to the many-tries algorithm.
@end menu


@noindent
Stochastic search techniques are used when the structure of a space is
not well understood or is not smooth, so that techniques like Newton's
method (which requires calculating Jacobian derivative matrices) cannot
be used. In particular, these techniques are frequently used to solve
combinatorial optimization problems, such as the traveling salesman
problem.

The goal is to find a point in the space at which a real valued ``energy
function'' (or ``cost function'') is minimized.  Simulated annealing is
a minimization technique which has given good results in avoiding local
minima; it is based on the idea of taking a random walk through the
space at successively lower temperatures, where the probability of
taking a step is given by a Boltzmann distribution.


@c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node annealing algorithm
@section The basic algorithm


@noindent
Here is an explanation of the basic algorithm. The idea is to generate
at random new configurations in the solution's space, and apply two
criteria to decide if the a new configuration must be accepted or
not. The criteria are: if lower energy accept, if upper energy accept
with a probability from a Boltzmann distribution.

It goes like this:

@enumerate
@item
interpret the start configuration as @emph{current} and also register it
as @emph{best so far};

@item
start a number of iterations at fixed temperature:

@enumerate a
@item
compute a @emph{new} configuration by taking a random step from the
@emph{current} configuration;

@item
evaluate the @emph{new} configuration's energy:

@itemize
@item
if @code{new_E <= best_E}: register the @emph{new} configuration as both
@emph{best so far} and @emph{current};

@item
else if @code{new_E <= current_E}: register the @emph{new} configuration
as @emph{current};

@item
else compute:

@example
R = exp(-(new_E - best_E)/(k * T))
@end example

@noindent
where @code{T} is the current temperature and @code{k} the Boltzmann
constant; if @code{R} is greater than a random number in the range
@code{[0, 1)}: register the @emph{new} configuration as @emph{current};

@item
else: discard the @emph{new} configuration;
@end itemize

@item
if not done all the iterations: go back to @code{a};
@end enumerate

@item
cool the temperature, the new value is:

@example
T_new = T / mu
@end example

@noindent
where @code{mu} is the damping factor: it must be a number greater than
@code{1};

@item
if the new temperature is less than the selected minimum value: stop and
report the better configuration as result;

@item
go to 2.
@end enumerate

Additionally some algorithms allow restarting, between steps 4 and 5: if
the new temperature is less than the selected restart value, discard the
@emph{current} configuration replacing it with the @emph{best so far}.

Notes:

@itemize
@item
there are two nested loops: the outer does as many iterations as
required to cool the temperature from the initial value to the minimum;
the inner does a fixed number of iterations at the same temperature.

@item
at least one outer iteration is performed, so the number of outer
iterations can be computed like this:

@example
initial = 100;
minimum = 1;
damping = 1.005;
count   = 1;

for (l = initial; l >= miminum; l /= damping, ++count)
  ;
/* count = 925 */
@end example

@item
the cooling waveform of the temperature is somewhat like an exponential;
for the example above the application of nonlinear multifitting with the
exponential model returns the following:

@example
T(x) = A exp(-lam x)    A=99.9999999173883  lam=4.60350080940739
@end example

@noindent
which fits very well the curve;

@item
the value:

@example
R = exp(-(new_E - best_E)/(k * T))
@end example

@noindent
is computed only if @code{new_E > best_E}, so it is always:

@example
new_E - best_E > 0  => R \in [0, 1)
@end example

@noindent
with @code{R} near @code{1} when @code{k * T} is high, and near @code{0}
when @code{k * T} is low.

@item
during the first iterations: the temperature drops rapidly and its value
is high; this means that a worse configuration is more likely to be
accepted;

@item
during the last iterations: the temperature drops slowly and its value
is low; this means that a worse configuration is less likely to be
accepted;

@item
with the basic algorithm only three configuration objects are in
existence at any instant: @emph{current}, @emph{best so far},
@emph{new}; so the memory space required to hold them can be allocated
at the beginning of the algorithm and released at the end by the user
code;

@item
the algorithm as no need to report errors if:

@enumerate
@item
we avoid memory allocation in the code that builds new configurations;

@item
building a new configuration from an existent one cannot fail.
@end enumerate
@end itemize


@c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node annealing types
@section Data types


@subsection Data structures


@deftp {Struct Typedef} annealing_configuration_t
A container for the configuration object. Public fields:

@table @code
@item void * data
pointer to a block of memory holding the configuration data; it can be
any type of data: the annealing code does not access it directly, it is
handled only by the user supplied functions;

@item double energy
the energy level associated to the configuration; it is computed by a
user supplied function.
@end table
@end deftp


@subsection User supplied functions


@noindent
In the following function types:

@itemize
@item
when the function is invoked by @function{annealing_simple_solve}
the argument @var{S} references a structure of type
@code{annealing_simple_workspace_t}.

@item
when the function is invoked by @function{annealing_multibest_solve}
the argument @var{S} references a structure of type
@code{annealing_multibest_workspace_t};

@item
when the function is invoked by @function{annealing_manytries_solve}
the argument @var{S} references a structure of type
@code{annealing_manytries_workspace_t}.
@end itemize

The @var{configuration} parameters are the values in the @code{data}
field of @code{annealing_configuration_t} structures.


@deftypefun double annealing_energy_fun_t (void * @var{S}, void * @var{configuration})
Must compute and return the energy value of @var{configuration}.
@end deftypefun


@deftypefun void annealing_step_fun_t (void * @var{S}, void * @var{configuration})
Must use the data in @var{S} to transform @var{configuration} to a new value.
@end deftypefun


@deftypefun double annealing_metric_fun_t (void * @var{S}, void * @var{configuration_a}, void * @var{configuration_b})
Must compute and return the distance between the two configurations. The
metric should be such that: the order in which the configurations are
handed to this function is not important.
@end deftypefun


@deftypefun void annealing_cooling_fun_t (void * @var{S})
Invoked to cool the temperature. Must update the @code{temperature}
field of the workspace structure.
@end deftypefun


@deftypefun void annealing_log_fun_t (void * @var{S})
Invoked once before the first iteration and then at the end of each
internal loop.
@end deftypefun


@deftypefun void annealing_copy_fun_t (void * @var{S}, void * @var{dst_configuration}, void * @var{src_configuration})
Invoked to clone a configuration.

It is responsibility of this function to free resources in
@var{dst_configuration} before overwriting them with values from
@var{src_configuration}.
@end deftypefun


@c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node annealing basic
@section Interface to the basic algorithm


@deftp {Struct Typedef} annealing_simple_workspace_t
Holds all the data required to run a basic simulated annealing
algorithm. It must be allocated and freed by the user code. Public
fields:

@table @code
@item size_t number_of_iterations_at_fixed_temperature
self explaining;

@item void * max_step_value
pointer to the value used to limit the ``distance'' between new
configurations and the current configuration; it can reference any type
of value, it is accessed only by the user supplied functions;

@item double boltzmann_constant
the constant used in the energy computation; it must be positive; when
tuning the parameters for a search a good start value is @code{1.0};

@item double temperature
the initial value for the temperature;

@item double minimum_temperature
the minimum value for the temperature: when the value in the field
@code{temperature} drops below this level the outer loop stops;

@item double restart_temperature
the temperature level that causes the @emph{current} configuration to be
reset to the @emph{best so far};

restarting is useful to prevent the search to get lost at low
temperature in a region with no interesting minima;

restarting is optional: if we select @code{DBL_MIN} as value, it is
never @code{temperature < restart_temperature} and the configuration is
never reset (@code{DBL_MIN} is defined in @file{float.h}, but any
negative value will do);

the value must be less than @code{temperature}, or the algorithm will
restart at each iteration;

@item int restart_flag
initially set to @code{0} by @function{annealing_simple_solve}, it
is set to @code{1} if/when the algorithm is restarted from the best
configuration;

@item double damping_factor
the coefficient used to cool the temperature; it must be a number
slightly above @code{1.0};

@item annealing_configuration_t current_configuration
holds the @emph{current} configuration value; its @code{data} field must
be initialised with a pointer to the start configuration;

@item annealing_configuration_t best_configuration
holds the @emph{best so far} configuration value; its @code{data} field
must be initialised with a pointer to a memory block large enough to
hold a configuration value; the memory block must be initialised with an
invalid value that can be recognised by @code{copy_function};

@item annealing_configuration_t new_configuration
holds the @emph{new} configuration value; its @code{data} field must be
initialised with a pointer to a memory block large enough to hold a
configuration value; the memory block must be initialised with an
invalid value that can be recognised by @code{copy_function};

@item gsl_rng * numbers_generator
the random number generator used to apply the Boltzmann distribution
acceptance criterion; it can be used also to generate the random step;

@item annealing_energy_fun_t * energy_function
the user supplied function used to compute the energy of a
configuration;

@item annealing_step_fun_t * step_function
the user supplied function used to compute the @emph{new} configuration
from the @emph{current} configuration;

@item annealing_cooling_fun_t * cooling_function
the user supplied function used to cool the temperature; it can be
@null{} to select the default cooling algorithm;

@item annealing_log_fun_t * log_function
the user supplied function used to log the search path; it can be
@null{} if no logging is required;

@item annealing_copy_fun_t * copy_function
the user supplied function used to copy a configuration from an
allocation space to another;

@item void * params
this is a free field that can be used to hand data to the user supplied
functions.
@end table
@end deftp


@deftypefun void annealing_simple_solve (annealing_simple_workspace_t * @var{S})
Does the search.

The structure referenced by @var{S} must be allocated and initialised by
the user before invoking this function, and freed by the user after this
function has returned.

Space for the data referenced by the @code{current_configuration},
@code{best_configuration} and @code{new_configuration} fields in @var{S}
must be allocated by the user before invoking this function, and freed
by the user after this function has returned.

This function does no resource allocation, so it is perfectly all right
if the user supplied functions use a dynamic wind mechanism, like
@function{setjmp} and @function{longjmp}, to report errors.

When this function returns: the best configuration found is in the
@code{best_configuration} field.
@end deftypefun


@subsection Examples


@noindent
Find the minimum of @code{f(t) = -sin(t)/t}.

@example
/** ------------------------------------------------------------
 ** Headers.
 ** ----------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <float.h>
#include <gsl/gsl_rng.h>
#include "annealing.h"


static  annealing_energy_fun_t      energy_function;
static  annealing_step_fun_t        step_function;
static  annealing_log_fun_t         log_function;
static  annealing_copy_fun_t        copy_function;

/** ------------------------------------------------------------
 ** Main.
 ** ----------------------------------------------------------*/

int
main (void)
@{
  annealing_simple_workspace_t      S;
  double        configurations[3];
  double        max_step = 10.0;


  printf("sinc minimisation with simulated annealing\n");

  S.number_of_iterations_at_fixed_temperature = 10;
  S.max_step_value              = &max_step;

  S.temperature                 = 10.0;
  S.minimum_temperature         = 1.0e-6;
  S.restart_temperature         = DBL_MIN; /* do not restart */
  S.boltzmann_constant          = 1.0;
  S.damping_factor              = 1.005;

  S.energy_function             = energy_function;
  S.step_function               = step_function;
  S.copy_function               = copy_function;
  S.log_function                = log_function;
  S.cooling_function            = NULL;

  S.numbers_generator           = gsl_rng_alloc(gsl_rng_rand);
  gsl_rng_set(S.numbers_generator, 15);

  S.current_configuration.data  = &(configurations[0]);
  S.best_configuration.data     = &(configurations[1]);
  S.new_configuration.data      = &(configurations[2]);

  configurations[0] = 100.0;

  annealing_simple_solve(&S);

  printf("final best solution: %f, expected 0.0\n",
         configurations[1]);

  gsl_rng_free(S.numbers_generator);
  exit(EXIT_SUCCESS);
@}

/** ------------------------------------------------------------
 ** Iteration functions.
 ** ----------------------------------------------------------*/

static double
alea (annealing_simple_workspace_t * S)
@{
  double        max_step = *((double *)S->max_step_value);

  return (2.0 * gsl_rng_uniform(S->numbers_generator) - 1.0) * max_step;
@}

/* ------------------------------------------------------------ */

double
energy_function (void * dummy, void * configuration)
@{
  double        C = *((double *)configuration);

  return -sin(C)/C;
@}
void
step_function (void * W, void * configuration)
@{
  annealing_simple_workspace_t * S = W;
  double *      C = (double *)configuration;
  double        c;

  do c = *C + alea(S); while (fabs(c) > 120.0);
  *C = c;
@}
void
log_function (void * W)
@{
  annealing_simple_workspace_t * S = W;
  double        current = *((double *)S->current_configuration.data);
  double        best    = *((double *)S->best_configuration.data);

  printf("current %f (energy %f), best %f (energy %f)\n",
         current, S->current_configuration.energy,
         best,    S->best_configuration.energy);
@}

/** ------------------------------------------------------------
 ** Configuration handling functions.
 ** ----------------------------------------------------------*/

void
copy_function (void * dummy,
               void * dst_configuration, void * src_configuration)
@{
  double *      dst = dst_configuration;
  double *      src = src_configuration;

  *dst = *src;
@}

/* end of file */
@end example


@c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node annealing multi
@section Interface to the multi--best algorithm


@noindent
To understand this section you have to read @ref{annealing algorithm}
first.

The multi--best algorithm works like the simple one, but keeps as result
a number of best configurations. It allows a two step search:

@enumerate
@item
find @code{N} promising configurations using @function{annealing_multibest_solve};

@item
explore the neighbourhood of each of the best configurations using
@function{annealing_simple_solve};
@end enumerate


When using the multi--best algorithm there is no restart option.


@deftp {Struct Typedef} annealing_multibest_workspace_t
Holds all the data required to run a multi--best simulated annealing
algorithm. It must be allocated and freed by the user code. Public
fields:

@table @code
@item size_t number_of_iterations_at_fixed_temperature
self explaining;

@item size_t max_number_of_best_configurations
maximum number of best configurations to register;

@item size_t best_configurations_count
number of best configurations currently registered; at the beginning of
the search this field is set to @code{1}, to account that the start
configuration is registered as best so far;

@item void * max_step_value
pointer to the value used to limit the ``distance'' between new
configurations and the current configuration; it can reference any type
of value, it is accessed only by the user supplied functions;

@item double minimum_acceptance_distance
when evaluating a new promising configuration: the vector of better
configurations is split in two: better than the promising, worse than
the promising; the promising configuration is accepted if its distance
from the better configurations is greater than this value;

@item double boltzmann_constant
the constant used in the energy computation; it must be positive; when
tuning the parameters for a search a good start value is @code{1.0};

@item double temperature
the initial value for the temperature;

@item double minimum_temperature
the minimum value for the temperature: when the value in the field
@code{temperature} drops below this level the outer loop stops;

@item double damping_factor
the coefficient used to cool the temperature; it must be a number
slightly above @code{1.0};

@item annealing_configuration_t current_configuration
holds the @emph{current} configuration value; its @code{data} field must
be initialised with a pointer to the start configuration;

@item annealing_configuration_t new_configuration
holds the @emph{new} configuration value; its @code{data} field must be
initialised with a pointer to a memory block large enough to hold a
configuration value; the memory block must be initialised with an
invalid value that can be recognised by @code{copy_function};

@item annealing_configuration_t * best_configurations
pointer to an array of @code{max_number_of_best_configurations}
structures, allocated by the user, that will reference the @emph{best so
far} configurations; the @code{data} fields of each structure must be
initialised with a pointer to a memory block large enough to hold a
configuration value; the memory block must be initialised with an
invalid value that can be recognised by @code{copy_function};

@item gsl_rng * numbers_generator
the random number generator used to apply the Boltmann distribution
acceptance criterion; it can be used also to generate the random step;

@item annealing_energy_fun_t * energy_function
the user supplied function used to compute the energy of a
configuration;

@item annealing_step_fun_t * step_function
the user supplied function used to compute the @emph{new} configuration
from the @emph{current} configuration;

@item annealing_cooling_fun_t * cooling_function
the user supplied function used to cool the temperature; it can be
@null{} to select the default cooling algorithm;

@item annealing_log_fun_t * log_function
the user supplied function used to log the search path; it can be
@null{} if no logging is required;

@item annealing_copy_fun_t * copy_function
the user supplied function used to copy a configuration from an
allocation space to another;

@item annealing_metric_fun_t * metric_function
the user supplied function used to compute the distance between two
configurations;

@item void * params
this is a free field that can be used to hand data to the user supplied
functions.
@end table
@end deftp


@deftypefun void annealing_multibest_solve (annealing_multibest_workspace_t * @var{S})
Does the search.

The structure referenced by @var{S} must be allocated and initialised by
the user before invoking this function, and freed by the user after this
function has returned.

Space for @code{current_configuration}, @code{new_configuration} and the
@code{best_configurations} array in @var{S} must be allocated by the
user before invoking this function, and freed by the user after this
function has returned.

This function does no resource allocation, so it is perfectly all right
if the user supplied functions use a dynamic wind mechanism, like
@function{setjmp} and @function{longjmp}, to report errors.

When this function returns: the best configurations found are in the
@code{best_configurations} array.
@end deftypefun


@subsection Examples


@noindent
Find 4 local minima of @code{f(t) = -sin(t)/t}.

@example
/** ------------------------------------------------------------
 ** Headers.
 ** ----------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <float.h>
#include <gsl/gsl_rng.h>
#include "annealing.h"


static  annealing_energy_fun_t      energy_function;
static  annealing_step_fun_t        step_function;
static  annealing_metric_fun_t      metric_function;
static  annealing_log_fun_t         log_function;
static  annealing_copy_fun_t        copy_function;

/** ------------------------------------------------------------
 ** Main.
 ** ----------------------------------------------------------*/

int
main (void)
@{
  annealing_multibest_workspace_t   S;
  annealing_configuration_t         array[4];
  double        configurations[2+4]; /* new, current and 4 best */
  double        max_step = 10.0;
  

  printf("multi-best sinc minimisation with simulated annealing\n");

  S.number_of_iterations_at_fixed_temperature = 10;
  S.max_step_value              = &max_step;
  S.minimum_acceptance_distance = 2.0;

  S.temperature                 = 10.0;
  S.minimum_temperature         = 1.0e-6;
  S.boltzmann_constant          = 1.0;
  S.damping_factor              = 1.005;

  S.energy_function             = energy_function;
  S.step_function               = step_function;
  S.copy_function               = copy_function;
  S.log_function                = log_function;
  S.metric_function             = metric_function;
  S.cooling_function            = NULL;

  S.numbers_generator           = gsl_rng_alloc(gsl_rng_rand);
  gsl_rng_set(S.numbers_generator, 15);

  S.max_number_of_best_configurations = 4;
  S.current_configuration.data  = &(configurations[0]);
  S.new_configuration.data      = &(configurations[1]);
  S.best_configurations         = array;

  array[0].data         = &(configurations[2]);
  array[1].data         = &(configurations[3]);
  array[2].data         = &(configurations[4]);
  array[3].data         = &(configurations[5]);
  configurations[0] = 100.0;

  annealing_multibest_solve(&S);

  printf("found %u best solutions:", S.best_configurations_count);
  for (size_t i=0; i<S.best_configurations_count; ++i)
    @{
      double *	value = array[i].data;
      printf(" %.5f", *value);
    @}

  gsl_rng_free(S.numbers_generator);
  exit(EXIT_SUCCESS);
@}

/** ------------------------------------------------------------
 ** Iteration functions.
 ** ----------------------------------------------------------*/

static double
alea (annealing_multibest_workspace_t * S)
@{
  double        max_step = *((double *)S->max_step_value);

  return (2.0 * gsl_rng_uniform(S->numbers_generator) - 1.0) * max_step;
@}

/* ------------------------------------------------------------ */

double
energy_function (void * dummy, void * configuration)
@{
  double        C = *((double *)configuration);

  return -sin(C)/C;
@}
void
step_function (void * W, void * configuration)
@{
  annealing_multibest_workspace_t * S = W;
  double *      C = (double *)configuration;
  double        c;

  do c = *C + alea(S); while (fabs(c) > 120.0);
  *C = c;
@}
double
metric_function (void * dummy, void * configuration_a, void * configuration_b)
@{
  double        A = *((double *)configuration_a);
  double        B = *((double *)configuration_b);

  return fabs(A - B);
@}
void
log_function (void * W)
@{
  annealing_multibest_workspace_t * S = W;
  double        current = *((double *)S->current_configuration.data);


  printf("current %5.5g (energy %.4f), worst best energy %.4f, best (%u):",
         current, S->current_configuration.energy,
         S->best_configurations[S->best_configurations_count-1].energy,
         S->best_configurations_count);
  for (size_t i=0; i<S->best_configurations_count; ++i)
    @{
      double *	value = S->best_configurations[i].data;
      printf(" %.5f", *value);
    @}
  printf("\n");
@}

/** ------------------------------------------------------------
 ** Configuration handling functions.
 ** ----------------------------------------------------------*/

void
copy_function (void * dummy, void * dst_configuration, void * src_configuration)
@{
  double *      dst = dst_configuration;
  double *      src = src_configuration;

  *dst = *src;
@}

/* end of file */
@end example


@c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node annealing many
@section Interface to the many--tries algorithm


@noindent
To understand this section you have to read @ref{annealing algorithm}
first.

The many--tries algorithm makes use of the Monte Carlo method to select
the new configuration. The algorithm itself is very simple, but its
meaning is not immediate to understand if one does not know the
Boltzmann distribution.


@subsection The Boltzmann distribution


@noindent
Let's consider a volume of gas composed by @code{N} particles at a
temperature @code{T}. We can partition the particles in @code{I} sets,
indexed by @code{i \in [1, I]}, such that the number of particles in the
@code{i}--th set is @code{N_i} and:

@example
    I
N = S N_i
   i=1 
@end example

@noindent
We do the partition so that: in each set all the particles share the
same energy level @code{E_i}.

The Boltzmann distribution equation is:

@example
         g_i exp(-E_i / (k T))
N_i/N = ------------------------
         I
         S g_j exp(-E_j / (k T))
        j=1
@end example

@noindent
where @code{k} is the Boltzmann constant; if we know the temperature
@code{T} and all the possible energy states @code{E_i}, we can compute
the fraction of particles in each state.

Altenatively: the fraction @code{N_i/N} is the probability that a
particle randomly selected in the gas is in the state @code{E_i}.

Given two numbers @code{N_i} and @code{N_j}, and assuming @code{g_i =
g_j}, we can write:

@example
          g_i exp(-E_i / (k T))
N_i/N_j = --------------------- = exp(-(E_i - E_j) / (k T))
          g_j exp(-E_j / (k T))
@end example

@noindent
which gives us the probability centred around the state @code{E_j}.


@subsection Monte Carlo method


@noindent
Let's say that we have a gas with @code{I} possible states, for which we
can compute the energies @code{E_i}, @code{i \in [1, I]}. Using the
Boltzmann distribution centred around a known level @code{E} having
@code{N} particles:

@example
N_i/N = exp(-(E_i - E) / (k T))            i \in [1, I]
@end example

@noindent
we can compute the fractions @code{N_i/N}.

The Monte Carlo method simulates the random extraction of a particle and
the determination of its energy state:

@enumerate
@item
compute samples of a coordinate @code{X}:

@example
X_0 = 0      X_i = N_i/N + X_@{i-1@}       i \in [1, I]
@end example

@item
generate a random number @code{x} from a uniform distribution in the
range @code{[0, X_I]};

@item
select the interval for which @code{x \in [X_@{i-1@}, X_i]};
@end enumerate

@noindent
the result of the simulation is that the particle has energy state
@code{E_i}, so it is in the state @code{i}.


@subsection Application to simulated annealing


@noindent
To apply the method we substitute the number of iterations at fixed
temperature with the following process:

@enumerate
@item
create a number @code{I-1} of new configurations; add the current
configuration, obtaining a set of @code{I} configurations;

@item
for each configuration: compute the energy level @code{E_i} centred
around the energy of the current configuration;

@item
apply the Monte Carlo method to select a state;
@end enumerate

@noindent
the configuration associated to the selected state is the new
configuration.

We notice that:

@itemize
@item
the fraction associated to the current configuration is:

@example
N_cur/N = exp(-(E - E) / (k T)) = 1
@end example

@item
the fraction associated to a configuration with energy higher than
@code{E} is:

@example
E_hi > E     =>      (E_hi - E) > 0
             =>      N_hi/N = exp(-(E_hi - E) / (k T)) < 1
@end example

@noindent
when the temperature is low the exponential becomes infinitesimal and
the library forces the fraction to the value of @code{0.0};

@item
the fraction associated to a configuration with energy lower than
@code{E} is:

@example
E_lo < E     =>      (E_lo - E) < 0
             =>      N_lo/N = exp(-(E_lo - E) / (k T)) > 1
@end example

@noindent
when the temperature is low the exponential becomes huge and the
library forces the fraction to the value of @code{10.0};
@end itemize

@noindent
so the lower energy configurations have more probability to be selected
than the current and higher energy ones, but still there is the
possibility to select a higher energy configuration.


@subsection Interface


@deftp {Struct Typedef} annealing_manytries_workspace_t
Holds all the data required to run a many-tries simulated annealing
algorithm. It must be allocated and freed by the user code. Public
fields:

@table @code
@item size_t number_of_tries
the number of new configurations to generate at fixed temperature; this
is the @code{I-1} number;

@item void * max_step_value
pointer to the value used to limit the ``distance'' between new
configurations and the current configuration; it can reference any type
of value, it is accessed only by the user supplied functions;

@item double boltzmann_constant
the constant used in the energy computation; it must be positive; when
tuning the parameters for a search a good start value is @code{1.0};

@item double temperature
the initial value for the temperature;

@item double minimum_temperature
the minimum value for the temperature: when the value in the field
@code{temperature} drops below this level the loop stops;

@item double restart_temperature
the temperature level that causes the @emph{current} configuration to be
reset to the @emph{best so far};

restarting is useful to prevent the search to get lost at low
temperature in a region with no interesting minima;

restarting is optional: if we select @code{DBL_MIN} as value, it is
never @code{temperature < restart_temperature} and the configuration is
never reset (@code{DBL_MIN} is defined in @file{float.h}, but any
negative value will do);

the value must be less than @code{temperature}, or the algorithm will
restart at each iteration;

@item int restart_flag
initially set to @code{0} by @function{annealing_manytries_solve}, it
is set to @code{1} if/when the algorithm is restarted from the best
configuration;

@item double damping_factor
the coefficient used to cool the temperature; it must be a number
slightly above @code{1.0};

@item annealing_configuration_t current_configuration
holds the @emph{current} configuration value; its @code{data} field must
be initialised with a pointer to the start configuration;

@item annealing_configuration_t best_configuration
holds the @emph{best so far} configuration value; its @code{data} field
must be initialised with a pointer to a memory block large enough to
hold a configuration value; the memory block must be initialised with an
invalid value that can be recognised by @code{copy_function};

@item annealing_configuration_t * new_configurations
pointer to an array of @code{number_of_tries} structures used to hold
references to the @emph{new} configurations; the @code{data} field of
the structures must be initialised with a pointer to a memory block
large enough to hold a configuration value; the memory block must be
initialised with an invalid value that can be recognised by
@code{copy_function};

@item double * monte_carlo_coordinates
pointer to an array of @code{number_of_tries} values used to store the
Monte Carlo method coordinates for the new configurations (the
coordinate for the current configuration is always @code{1.0}, so it
does not need a variable);

@item gsl_rng * numbers_generator
the random number generator used to apply the Boltzmann distribution
acceptance criterion; it can be used also to generate the random step;

@item annealing_energy_fun_t * energy_function
the user supplied function used to compute the energy of a
configuration;

@item annealing_step_fun_t * step_function
the user supplied function used to compute the @emph{new} configuration
from the @emph{current} configuration;

@item annealing_cooling_fun_t * cooling_function
the user supplied function used to cool the temperature; it can be
@null{} to select the default cooling algorithm;

@item annealing_log_fun_t * log_function
the user supplied function used to log the search path; it can be
@null{} if no logging is required;

@item annealing_copy_fun_t * copy_function
the user supplied function used to copy a configuration from an
allocation space to another;

@item void * params
this is a free field that can be used to hand data to the user supplied
functions.
@end table
@end deftp


@deftypefun void annealing_manytries_solve (annealing_manytries_workspace_t * @var{S})
Does the search.

The structure referenced by @var{S} must be allocated and initialised by
the user before invoking this function, and freed by the user after this
function has returned.

Space for the data referenced by the @code{current_configuration},
@code{best_configuration} and @code{new_configuration} fields in @var{S}
must be allocated by the user before invoking this function, and freed
by the user after this function has returned.

This function does no resource allocation, so it is perfectly all right
if the user supplied functions use a dynamic wind mechanism, like
@function{setjmp} and @function{longjmp}, to report errors.

When this function returns: the best configuration found is in the
@code{best_configuration} field.
@end deftypefun


@subsection Examples


@noindent
Find minimum of @code{f(t) = -sin(t)/t}.


@example
/** ------------------------------------------------------------
 ** Headers.
 ** ----------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <float.h>
#include <gsl/gsl_rng.h>
#include "annealing.h"


static	annealing_energy_fun_t	energy_function;
static	annealing_step_fun_t	step_function;
static	annealing_log_fun_t		log_function;
static	annealing_copy_fun_t	copy_function;

/** ------------------------------------------------------------
 ** Main.
 ** ----------------------------------------------------------*/

#define TRIES   10

int
main (int argc, char ** argv)
@{
  annealing_manytries_workspace_t   S;
  annealing_configuration_t         array[TRIES];
  double        configurations[2 + TRIES]; /* best, current and new tries */
  double        monte_carlo_coordinates[TRIES];
  double        max_step = 10.0;

  
  printf("many-tries sinc minimisation with simulated annealing\n");

  S.number_of_iterations_at_fixed_temperature = 10;
  S.max_step_value              = &max_step;

  S.temperature                 = 10.0;
  S.minimum_temperature         = 1.0e-6;
  S.restart_temperature         = DBL_MIN; /* do not restart */
  S.boltzmann_constant          = 1.0;
  S.damping_factor              = 1.005;

  S.energy_function             = energy_function;
  S.step_function               = step_function;
  S.copy_function               = copy_function;
  S.log_function                = log_function;
  S.cooling_function            = NULL;

  S.numbers_generator           = gsl_rng_alloc(gsl_rng_rand);
  gsl_rng_set(S.numbers_generator, 15);

  S.current_configuration.data  = &(configurations[0]);
  S.best_configuration.data     = &(configurations[1]);
  S.new_configurations          = array;
  S.monte_carlo_coordinates     = monte_carlo_coordinates;
  S.number_of_tries             = TRIES;

  for (size_t i=0; i<S.number_of_tries; ++i)
    array[i].data = &(configurations[i+2]);

  configurations[0] = 100.0;

  annealing_manytries_solve(&S);

  printf("final best solution: %f, global 0.0\n", configurations[1]);

  gsl_rng_free(S.numbers_generator);
  exit(EXIT_SUCCESS);
@}

/** ------------------------------------------------------------
 ** Iteration functions.
 ** ----------------------------------------------------------*/

static double
alea (annealing_manytries_workspace_t * S)
@{
  double        max_step = *((double *)S->max_step_value);

  return (2.0 * gsl_rng_uniform(S->numbers_generator) - 1.0) * max_step;
@}

/* ------------------------------------------------------------ */

double
energy_function (void * dummy, void * configuration)
@{
  double        C = *((double *)configuration);

  return -sin(C)/C;
@}
void
step_function (void * W, void * configuration)
@{
  annealing_manytries_workspace_t * S = W;
  double *      C = (double *)configuration;
  double        c;

  do c = *C + alea(S); while (fabs(c) > 120.0);
  *C = c;
@}
void
log_function (void * W)
@{
  annealing_manytries_workspace_t * S = W;
  double *      current = (double *)S->current_configuration.data;
  double *      best    = (double *)S->best_configuration.data;

  printf("current %f (energy %f), best %f (energy %f)\n",
         *current, S->current_configuration.energy,
         *best,    S->best_configuration.energy);
@}

/** ------------------------------------------------------------
 ** Configuration handling functions.
 ** ----------------------------------------------------------*/

void
copy_function (void * dummy, void * dst_configuration, void * src_configuration)
@{
  double *      dst = dst_configuration;
  double *      src = src_configuration;

  *dst = *src;
@}

/* end of file */
@end example


@c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node References
@appendix Bibliography and references


@noindent
``Boltzmann distribution.'' Wikipedia, The Free Encyclopedia. 24 Jan
2007, 14:52 UTC. Wikimedia Foundation, Inc. 26 Feb 2007
@url{http://en.wikipedia.org/w/index.php?title=Boltzmann_distribution&oldid=102908405}.




@c ------------------------------------------------------------

@include fdl.texiinc
@include gpl.texiinc

@c ------------------------------------------------------------
@node library version
@appendix How to interpret the library version


@quotation
@strong{NOTE} This section is not specific to this package; it is an
explanation of library interface version numbering that the author uses
for all its C libraries.
@end quotation

@noindent
This package is distributing one or more libraries; this package has a
version number and each library has an interface version number, package
and interface versions are independent.


@appendixsec Package version

@noindent
The package version tracks the development of the source code: every
time the source code is modified the package version is
incremented. There are three numbers: major, minor, patch level.

@table @code
@item major
Incremented before big rewritings or additions.
@item minor
Incremented to track incremental development of the code.
@item patch level
For stable versions: incremented for bug fixes and very small additions
that were forgotten in the last minor update.
@end table

The package has also a letter that indicates the status of the release:
@code{a} for experimental or ``alpha'', @code{b} for testing or
``beta'', @code{.} for stable.

A full version number looks like this:

@table @code
@item 1.2a3
major @code{1}, minor @code{2}, patch level @code{3}, status alpha;
@item 10.23b34
major @code{10}, minor @code{23}, patch level @code{34}, status beta;
@item 1.2.3
major @code{1}, minor @code{2}, patch level @code{3}, status stable.
@end table

The reason for the letter to be between the minor number and the patch
level is that it is more important:

@itemize
@item
when starting to develop version @code{1.2} (major @code{1}, minor
@code{2}), the last stable version of the @code{1.1} branch is taken and
the project starts with alpha versions; each alpha has a patch level:
@code{1.2a0}, @code{1.2a1}, @dots{};
@item
when experimental development, is finished the package is moved to
testing and the status to beta: @code{1.2b0}, @code{1.2b1}, @dots{} so
the first beta version is newer than the last alpha version;
@item
when testing is finished, the package is moved to stable status:
@code{1.2.0}, @code{1.2.1}, @dots{} so the first stable version is newer
than the last beta version.
@end itemize

@noindent
summary:

@example
1.1.x < 1.2a0 < 1.2a1 < ... < 1.2b0 < 1.2b1 < ... < 1.2.0 < 1.2.1
@end example


@appendixsec Interface version

@noindent
The interface version changes only when the public interface of a
library (public function prototypes and data types) is modified. There
are two numbers: major and minor.

@table @code
@item major
Establishes a set of: functions, data types, code behaviour that will
not change until the next major number update. Code written for the
first release of the library with a major interface number (@code{1.0}),
will work unchanged with all the libraries with the same major interface
number (@code{1.1}, @code{1.2}, @dots{}); if it does not: it is a
library bug, please signal this to the author using the bug tracking
system.

The only exception to this rule is the wrong behaviour caused by bugs;
code that relies on buggy behaviour of a package version may, not work
with subsequent package versions with the same major interface number.

@item minor
Establishes a set of: functions, data types, code behaviour that will
not change until the next major number update. This set is added to the
set of the previous interface version.
@end table

The library file installed on our system has name composed with the
interface number; example: if the package has version @code{1.2.3} and
the interface has version @code{1.1}, the library file is called
@file{libmy1.1.so}.

Even if the interface number has not changed, and the library file has
the same name: when an installed shared library is updated to a new
package version, programs and libraries depending on it will have to be
recompiled, because the internals of the library file will have changed.

@c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node Concept Index
@appendix An entry for each concept
     
@printindex cp
     
@node Function Index
@appendix An entry for each function. 

@printindex fn

@node Variable Index
@appendix An entry for each variable. 

@printindex vr

@node Type Index
@appendix An entry for each type. 

@printindex tp

@contents
@bye

@c end of file
@c Local Variables:
@c mode: texinfo
@c page-separator: \"^@c -+$\"
@c End:
